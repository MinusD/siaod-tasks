# Лабораторная 1 | Побитовые операторы

### Номер 1.a
Реализуйте вышеприведённый пример, проверьте правильность результата в том числе и на 
других значениях х.

```cpp
cout << "Task 1.a\n";
unsigned char x = 255; // 255 16 (00010000)
unsigned char mask = 1;
x = x & (~(mask << 4));
cout << bitset<8>(x);
```
Для проверки введём число `16`, что в двоичной система `00010000`, после выполнения программы получим `00000000`, следовательно программа работает.

### Номер 1.б
Реализуйте по аналогии с предыдущим примером установку 7-го бита числа в единицу.

```cpp
cout << "\n\nTask 1.б\n";
unsigned char x = 0;
unsigned char mask = 1;
x = x | (mask << 6);
cout << bitset<8>(x);
```
Аналагично предыдущему заданию, только смещение на большее количество бит.

### Номер 1.в
Реализуйте код листинга 1, объясните выводимый программой результат.

```cpp
cout << "\n\nTask 1.в\n";
unsigned int a = 25;
const int n = sizeof(int) * 8;
unsigned maska = (1 << n - 1); // Помещаем 1 в старший разряд
cout << "Start mask: " << bitset<n>(maska) << endl;
cout << "Result: ";
for (int i = 1; i <= n; i++) {
    cout << ((a & maska) >> (n - i));
    maska >>= 1;
}
```

Пррграмма выводит `00000000000000000000000000011001`, если перевести в двоичную сс, то получиться число `25`. Программа изменяя расположение единички в маске, выводит биты переменной `a` начиная со старшего разряда.

### Номер 2.а
 Реализуйте вышеописанный пример с вводом произвольного набора до 8-ми чисел (со значениями от 0 до 7) и его сортировкой битовым массивом в виде числа типа unsigned char. Проверьте работу программы.

```cpp
cout << "\n\nTask 2.а\n";
unsigned char data = 0;
short int size, tmp;
cout << "Enter array size: ";
cin >> size;
for (int i = 0; i < size; i++) 
{
    cin >> tmp;
    data = data | (1 << tmp);
}
//cout << bitset<8>(data) << endl;
cout << "Sorted array: ";
for (int i = 0; i < sizeof(data) * 8; i++)
{
    if ((1 << i) & data) cout << i << " ";
}
```

После того, как ввели размер массива, пробегаемся циклом и с помощию статичной маски (цифра `1`), запоминаем какие цифры мы ввели. Для вывода используем конструкцию работающую по аналагичному принципу. Только вместо дизъюнкции, используем коньюнкцию.

### Номер 2.б
Адаптируйте вышеприведённый пример для набора из 64-х чисел (со начениями от 0 до 63) с битовым массивом в виде числа типа unsigned long long.

```cpp
cout << "\n\nTask 2.б\n";
unsigned long long data = 0, mask = 1;
short int size, tmp;
cout << "Enter array size: ";
cin >> size;
for (int i = 0; i < size; i++)
{
    mask = 1;
    cin >> tmp;
    data = data | (mask << tmp);
}
cout << "Sorted array: ";
for (int i = 0; i < sizeof(data) * 8; i++)
{
    mask = 1;
    if ((mask << i) & data) cout << i << " ";
}
```

Аналагично предыдущему заданию, за исключением того, что `1`, сменились на единичные маски.

### Номер 2.в
Исправьте программу задания 2.б, чтобы для сортировки набора из 64-х чисел использовалось не одно число типа unsigned long long, а линейный массив чисел типа unsigned char.

```cpp
cout << "\n\nTask 2.в\n";
int size, tmp;
vector<unsigned char> data;
cout << "Enter array size: ";
cin >> size;
for (int i = 0; i < 8; i++)
    data.push_back(0);
for (int i = 0; i < size; i++) {
    cin >> tmp;
    data[tmp / 8] = data[tmp / 8] | (1 << (tmp % 8));
}
cout << "Sorted array: ";
for (int i = 0; i < 8; i++)
    for (int j = 0; j < 8; j++)
        if ((1 << j) & data[i]) cout << i * 8 + j << " ";
```

Поскольку у нас есть фиксированное максиамальное число (`63`), а размер `unsigned char` 1 байт, то размер вектора всегда будет `8`. Сначала заполняем его полностью нулями, и затем заполняем числами, аналагично предыдущим заданиям, за тем исключением, что сначала мы обращаемся по индексу.
